# SPDX-License-Identifier: AGPL-3.0-or-later
# lint: pylint
"""
Method ``link_token``
---------------------

The ``link_token`` method evaluates a request as :py:obj:`suspicious
<is_suspicious>` if the URL ``/client<token>.css`` is not requested by the
client.  By adding a random component (the token) in the URL, a bot can not send
a ping by request a static URL.

.. note::

   This method requires a redis DB and needs a HTTP X-Forwarded-For_ header.

.. _X-Forwarded-For:
   https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For

To get in use of this method a flask URL route needs to be added:

.. code:: python

   @app.route('/client<token>.css', methods=['GET', 'POST'])
   def client_token(token=None):
       link_token.ping(request, token)
       return Response('', mimetype='text/css')

And in the HTML template from flask a stylesheet link is needed (the value of
``link_token`` comes from :py:obj:`get_token`):

.. code:: html

   <link rel="stylesheet"
         href="{{ url_for('client_token', token=link_token) }}"
         type="text/css" />


Config
~~~~~~

.. code:: toml

   [botdetection.link_token]
   # Livetime (sec) of limiter's CSS token.
   TOKEN_LIVE_TIME = 600

   # Livetime (sec) of the ping-key from a client (request)
   PING_LIVE_TIME = 3600

   # Prefix of all ping-keys generated by link_token.get_ping_key
   PING_KEY = 'botdetection.link_token.PING_KEY'

   # Key for which the current token is stored in the DB
   TOKEN_KEY = 'botdetection.link_token.TOKEN_KEY'


Implementations
~~~~~~~~~~~~~~~

"""

from __future__ import annotations

import string
import random
import logging

import flask

from ._request_info import RequestInfo
from .config import Config
from ._redislib import RedisLib


logger = logging.getLogger(__name__)


PING_KEY = "botdetection.link_token.PING_KEY"
"""Prefix of all ping-keys generated by :py:obj:`get_ping_key`"""

TOKEN_KEY = "botdetection.link_token.TOKEN_KEY"
"""Key for which the current token is stored in the DB"""


def get_link_token(redislib: RedisLib | None, config: Config, request_info: RequestInfo, request: flask.Request):
    if redislib:
        return LinkToken(redislib, config, request_info, request)
    return None


class LinkToken:
    def __init__(self, redislib: RedisLib, config: Config, request_info: RequestInfo, request: flask.Request):
        self.redislib = redislib
        self.config = config
        self.request_info = request_info
        clear_ping_key = (
            self.request_info.network.compressed
            + request.headers.get("Accept-Language", "")
            + request.headers.get("User-Agent", "")
        )
        self.ping_key = PING_KEY + "[" + self.redislib.secret_hash(clear_ping_key) + "]"

    def is_suspicious(self, renew: bool = False):
        """Checks whether a valid ping is exists for this (client) network, if not
        this request is rated as *suspicious*.  If a valid ping exists and argument
        ``renew`` is ``True`` the expire time of this ping is reset to
        ``PING_LIVE_TIME``.

        """
        if not self.redislib.redis.get(self.ping_key):
            logger.info("missing ping (IP: %s) / request: %s", self.request_info.network.compressed, self.ping_key)
            return True

        if renew:
            self.redislib.redis.set(self.ping_key, 1, ex=self.config.botdetection.link_token.ping_live_time)

        logger.debug("found ping for (client) network %s -> %s", self.request_info.network.compressed, self.ping_key)
        return False

    def ping(self, token: str):
        """This function is called by a request to URL ``/client<token>.css``.  If
        ``token`` is valid a :py:obj:`PING_KEY` for the client is stored in the DB.
        The expire time of this ping-key is ``PING_LIVE_TIME``.

        """
        if not self.is_token_valid(token):
            return

        logger.debug(
            "store ping_key for (client) network %s (IP %s) -> %s",
            self.request_info.network.compressed,
            self.request_info.real_ip,
            self.ping_key,
        )

        self.redislib.redis.set(self.ping_key, 1, ex=self.config.botdetection.link_token.ping_live_time)

    def is_token_valid(self, token) -> bool:
        valid = token == self.get_token()
        logger.debug("token is valid --> %s", valid)
        return valid

    def get_token(self) -> str:
        """Returns current token.  If there is no currently active token a new token
        is generated randomly and stored in the redis DB.

        Config:

        - ``TOKEN_LIVE_TIME``
        - ``TOKEN_KEY``

        """
        token_key = self.config.botdetection.link_token.token_key
        token = self.redislib.redis.get(token_key)
        if token:
            # existing token
            token = token.decode("UTF-8")
        else:
            # no existing token --> create and store a new one
            token = "".join(random.choice(string.ascii_lowercase + string.digits) for _ in range(16))
            self.redislib.redis.set(token_key, token, ex=self.config.botdetection.link_token.token_live_time)
        return token
